// Generated by CoffeeScript 1.6.3
(function() {
  var Parser, fs, glob, nodePath, pugLex, pugParser, pugWalk, resolvePath;

  nodePath = require('path');

  fs = require('fs');

  glob = require('glob');

  pugLex = require('pug-lexer');

  pugParser = require('pug-parser');

  pugWalk = require('pug-walk');

  resolvePath = function(path, file, basedir, purpose) {
    if (path[0] !== '/' && !file) {
      throw new Error('the "filename" option is required to use "' + purpose + '" with "relative" paths');
    }
    if (path[0] === '/' && !basedir) {
      throw new Error('the "basedir" option is required to use "' + purpose + '" with "absolute" paths');
    }
    path = nodePath.join((path[0] === '/' ? basedir : nodePath.dirname(file)), path);
    if (nodePath.basename(path).indexOf('.') === -1) {
      path += '.jade';
    }
    return path;
  };

  Parser = (function() {
    function Parser(filename, directory, options) {
      var files;
      this.filename = filename;
      this.directory = directory;
      this.options = options;
      this.cache = {};
      this.files = {};
      filename = nodePath.relative(this.options.basedir, filename);
      this.addFile(filename);
      files = glob.sync("" + this.directory + "/**/*.jade");
      this.tree = this.getInheritance(filename, files);
      files = this.files;
      this.files = [];
      for (filename in files) {
        this.files.push(filename);
      }
      return this;
    }

    Parser.prototype.getInheritance = function(filename, files) {
      var branch, file, _fn, _i, _len,
        _this = this;
      this.addFile(filename);
      branch = {};
      if (branch[filename] == null) {
        branch[filename] = {};
      }
      _fn = function(file) {
        var e, relativeFile, string, _base;
        file = nodePath.normalize(file);
        relativeFile = nodePath.relative(_this.options.basedir, file);
        file = nodePath.join(_this.options.basedir, relativeFile);
        if ((_base = _this.cache)[file] == null) {
          _base[file] = {};
        }
        if (_this.cache[file].string != null) {
          string = _this.cache[file].string;
        } else {
          string = _this.cache[file].string = fs.readFileSync(file, 'utf8');
        }
        try {
          return pugWalk(pugParser(pugLex(string, file)), function(node) {
            var inheritance, newFile, path, relationship, type, _base1;
            type = node.type;
            switch (type) {
              case 'Extends':
              case 'RawInclude':
                path = resolvePath(node.file.path, file, _this.options.basedir, type);
                if (path === nodePath.join(_this.options.basedir, filename)) {
                  if (type === 'Extends') {
                    relationship = 'extendedBy';
                  } else if (type === 'RawInclude') {
                    relationship = 'includedBy';
                  }
                  newFile = {};
                  if (_this.cache[file].inheritance != null) {
                    inheritance = _this.cache[file].inheritance;
                  } else {
                    inheritance = _this.cache[file].inheritance = _this.getInheritance(relativeFile, files);
                  }
                  newFile = inheritance;
                  if ((_base1 = branch[filename])[relationship] == null) {
                    _base1[relationship] = [];
                  }
                  return branch[filename][relationship].push(newFile);
                }
            }
          });
        } catch (_error) {
          e = _error;
          throw e;
        }
      };
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        _fn(file);
      }
      return branch;
    };

    Parser.prototype.addFile = function(filename) {
      if (this.files[filename] == null) {
        return this.files[filename] = null;
      }
    };

    return Parser;

  })();

  module.exports = Parser;

}).call(this);
